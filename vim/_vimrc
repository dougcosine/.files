" sources
  exec "source " . expand('<sfile>:p:h') . "/vimrc_example.vim"

" settings
  behave xterm
  colorscheme slate         "change colors
  " for some reason PreProc(essing) gets highlighted red on white by default.
  " this makes it orange on gray
  hi PreProc guifg=orange guibg=#505050
  set gfn=Consolas:h9:cANSI "change font
  set expandtab             "convert \t characters to spaces
  set tabstop=2             "this and the following two lines
  set shiftwidth=2          "set the size of 'tabs' to 2 spaces
  set softtabstop=2
  set cindent               "enable C style indentation
  set cinkeys-=0#           "don't reset '#' comment lines to 0 indentation
  set indentkeys-=0#        "don't reset '#' comment lines to 0 indentation
  set mouse=                "disable crutch interaction
  set fdm=indent            "fold method (how folds are recognized
  set foldignore=           "was '#' allow comment folding
  set clipboard=unnamed     "use windows' clipboard???
  set guioptions-=m         "remove menu bar
  set guioptions-=T         "remove toolbar
  set guioptions-=R         "remove scroll bars (next 4 lines)
  set guioptions-=r
  set guioptions-=L
  set guioptions-=l
  set guioptions-=e         "remove gui tab labels
  set formatoptions+=j      "remove comment leader when joining lines
  set numberwidth=2         "minimum number of columns to display line numbers
  set shellslash            "use as separator for file paths
  set backup                "keep a backup file
  set history=10000         "keep 50 lines of command line history
  set ruler                 "show the cursor position all the time
  set showcmd               "display incomplete commands
  set incsearch             "do incremental searching
  set fileformat=unix       "use unix style line endings
  set fileformats=unix,dos  "no, really! use unix style line endings
  syntax on                 "switch syntax highlighting on
  set hlsearch              "highlight the last used search pattern
  "use file's location as working directory for shell commands
  set autochdir
  " allow backspacing over everything in insert mode
  set backspace=indent,eol,start
  " backspace, space, h, and l keys wrap to previous/next line
  set whichwrap+=bs
  " disable bell
  set vb t_vb=
  " enable the saving and restoring of screen positions.
  let g:screen_size_restore_pos = 1
  " To save and restore screen for each Vim instance.
  " This is useful if you routinely run more than one Vim instance.
  " For all Vim to use the same settings, change this to 0.
  let g:screen_size_by_vim_instance = 1

" if you want to run some command that moves the screen or unfolds folds
" but you want the screen and cursor in their original positions when
" you're done, then you can use this?
" cmd is a string that gets passed to execute
" StacicViewCall(":0")
" this would bring you to the first line... and then send you right back
" hopefully we can think of some better uses of this function /:
function! StaticViewCall(cmd)
  let screen = winsaveview() " save current screen/cursor state
  set nofoldenable           " disable folding so folds aren't opened
  execute a:cmd            | " run the supplied command
  set foldenable             " reenable folding
  call winrestview(screen)   " restore screen/cursor state
endfunction

" moves you to the first non whitespace character of the line
" if you were already there, moves you to the first character if the line
function! LineHome(mode)
  let isVisual = a:mode == 'v'
  if isVisual
    execute "normal! \<esc>"
    let colCurr = col('.')
    execute "normal! ^"
    if colCurr == col('.')
      execute "normal! gv0"
    else
      execute "normal! gv^"
    endif
  else
    let colCurr  = col('.')
    execute "normal! ^"
    if colCurr == col('.')
      execute "normal! 0"
    endif
  endif
  return ""
endfunction

" switches to diff mode and compares the current buffer to the version last
" saved in the filesystem.
" Usage: ':DiffSaved' to start
"        ':diffoff' or ':diffo' and close the 'Scratch' window to end
function! s:DiffWithSaved()
  let filetype=&ft
  diffthis
  vnew | r # | normal! 1Gdd
  diffthis
  exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
endfunction
com! DiffSaved call s:DiffWithSaved()

" pathogen
execute pathogen#infect()

" EasyMotion
  let g:EasyMotion_smartcase = 1
  let g:EasyMotion_leader_key = 'm'
  let g:EasyMotion_keys='asonidetuh'
  nmap     m  <Plug>(easymotion-prefix)
  nmap     mw <Plug>(easymotion-bd-w)
  nmap     mW <Plug>(easymotion-bd-W)
  nmap     me <Plug>(easymotion-bd-e)
  nmap     mE <Plug>(easymotion-bd-E)
  nmap     mj <Plug>(easymotion-j)
  nmap     mk <Plug>(easymotion-k)
  nmap     ml <Plug>(easymotion-lineforward)
  nmap     mh <Plug>(easymotion-linebackward)
  nnoremap my y``
  nnoremap mY y''
  nnoremap mc c``
  nnoremap mC c''
  nnoremap md ``d``
  nnoremap mD ''d''
  nnoremap m= ``=``
  " look into changing where the cursor ends up with indentation
  " so these actions will be repeatable.
  nnoremap m>  ``>``
  nnoremap m<  ``<``
  nnoremap mgu ``gu``
  nnoremap mgU ``gU``
  nmap     m/  <Plug>(easymotion-sn)
  nmap     mn  <Plug>(easymotion-next)
  nmap     mN  <Plug>(easymotion-prev)

" autocmds
  " strip white space from line endings on save
  au BufWritePre * call StaticViewCall('%s/\s\+$//e') | noh
  " start in insert mode for git commit messages
  au FileType gitcommit 1 | startinsert | :redraw
  " set some cobol extensions
  au BufRead,BufNewFile *.dc,*.fd,*.nm,*.sl,*.wk set ft=cobol

" mark
  " make M initiate setting marks, since I remapped m to EasyMotion's leader
  nnoremap M m

" diff specific
  if &diff
    " if we're in diff mode map ctrl+l to turn off search highlighting,
    " refresh syntax highlighting, and refresh the diff
    nnoremap <c-l> :noh<cr>:sil! syn-sync-first<cr>:diffu<cr>
    vnoremap <c-l> <c-c>:noh<cr>:sil! syn-sync-first<cr>:diffu<cr>gv
    inoremap <c-l> <c-o>:noh<cr><c-o>:sil! syn-sync-first<cr><c-o>:diffu<cr>
    " maximize the window
    au GUIEnter * simalt ~x
  else
    " if we're not in diff mode, just map ctrl+l to turn off search
    " highlighting and refresh syntax highlighting
    nnoremap <c-l> :noh<cr>:silent! syntax sync fromstart<cr>
    vnoremap <c-l> <c-c>:noh<cr>:silent! syntax sync fromstart<cr>gv
    inoremap <c-l> <c-o>:noh<cr><c-o>:silent! syntax sync fromstart<cr>
  endif

" leaders
  map <space> <nop>
  let mapleader = "\<space>"
  map - <localleader>
  let maplocalleader = "-"

" commands
  " Alt-Space is System menu
  if has("gui")
    noremap  <a-space> :simalt ~<cr>
    inoremap <a-space> <c-o>:simalt ~<cr>
    cnoremap <a-space> <c-c>:simalt ~<cr>
  endif

  " quick edit my vimrc
  nnoremap <leader>ek :tabnew $MYVIMRC<cr>
  " quick source my vimrc
  nnoremap <leader>ok :source $MYVIMRC<cr>

  " map ; to : in mode so it's easier to input commands
  noremap ; :
  " map q; to q: so we can get to the command editor
  noremap q; q:

  " map escape to remove search highlighting in normal mode
  if has("gui_running")
    nnoremap <esc> :noh<cr>
  else
    " if we're on the backup server highlighting won't work until we change
    " the term variable to ansi, but this change has to be made some time
    " after the vimrc is sourced. setting the TERM env var causes problems
    " with escape sequences, so we can't do that. setting term here in the
    " vimrc doesn't cause those problems, but it does't make colors work
    " properly either.
    " maybe add some logic so it only sets term the first
    " time <esc> is pressed? maybe don't worry about it?
    nnoremap <esc> :set term=ansi<cr>:noh<cr>
  endif

  " map forward and backward window switching in normal, visual, command
  " pending, and insert modes
  noremap  <leader>, <c-w>w
  nnoremap <leader>< <c-w>W

  " map tabclose to match cVim
  noremap <leader>x :tabclose<cr>

  " map f10 to echo the syntax groups the character under the cursor matches
  map <f10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name")
      \ . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
      \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" cursor movement
  " move to end of line with L
  noremap  L $
  " move to first non whitespace character of line with H
  " if you were already there, move to first character of line
  noremap  H :call LineHome('n')<cr>:echo<cr>
  vnoremap H :<c-u>call LineHome('v')<cr>

" modal operators
  " map escape to leave insert and visual modes and also remove highlighting
  inoremap <esc> <esc>l:noh<cr>
  vnoremap <esc> <esc>:noh<cr>

" text movement
  " move line under cursor down one line
  nnoremap <leader>- ddp
  " move line under cursor up one line
  nnoremap <leader>_ ddkP

" tabs
  nnoremap <leader>k gt
  nnoremap <leader>j gT
  nnoremap <leader>t :tabnew<space>

" text editing
  " surround word under cursor with various enclosing marks
  nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel
  nnoremap <leader>' viw<esc>a'<esc>hbi'<esc>lel
  nnoremap <leader>( viw<esc>a)<esc>hbi(<esc>lel
  nnoremap <leader>[ viw<esc>a]<esc>hbi[<esc>lel
  nnoremap <leader>{ viw<esc>a}<esc>hbi{<esc>lel

  " backspace in Visual mode deletes selection
  vnoremap <BS> d

" <nop>
  " Don't use Ex mode
  noremap Q <nop>

  " Don't use arrow keys
  noremap  <Left>  <nop>
  inoremap <Left>  <nop>
  noremap  <Right> <nop>
  inoremap <Right> <nop>
  noremap  <Up>    <nop>
  inoremap <Up>    <nop>
  noremap  <Down>  <nop>
  inoremap <Down>  <nop>

" abbreviations
  iabbrev @@ dougcosine@gmail.com
  iabbrev ssig -- <cr>Doug Coulson<cr>dougcosine@gmail.com









" restore size script from http://vim.wikia.com/wiki/Restore_screen_size_and_position
if has("gui_running")
  function! ScreenFilename()
    if has('amiga')
      return "s:.vimsize"
    elseif has('win32')
      return $HOME.'\_vimsize'
    else
      return $HOME.'/.vimsize'
    endif
  endfunction

  function! ScreenRestore()
    " Restore window size (columns and lines) and position
    " from values stored in vimsize file.
    " Must set font first so columns and lines are based on font size.
    let f = ScreenFilename()
    if has("gui_running") && g:screen_size_restore_pos && filereadable(f)
      let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
      for line in readfile(f)
        let sizepos = split(line)
        if len(sizepos) == 5 && sizepos[0] == vim_instance
          silent! execute "set columns=".sizepos[1]." lines=".sizepos[2]
          silent! execute "winpos ".sizepos[3]." ".sizepos[4]
          return
        endif
      endfor
    endif
  endfunction

  function! ScreenSave()
    " Save window size and position.
    if has("gui_running") && g:screen_size_restore_pos
      let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
      let data = vim_instance . ' ' . &columns . ' ' . &lines . ' ' .
            \ (getwinposx()<0?0:getwinposx()) . ' ' .
            \ (getwinposy()<0?0:getwinposy())
      let f = ScreenFilename()
      if filereadable(f)
        let lines = readfile(f)
        call filter(lines, "v:val !~ '^" . vim_instance . "\\>'")
        call add(lines, data)
      else
        let lines = [data]
      endif
      call writefile(lines, f)
    endif
  endfunction

  if !exists('g:screen_size_restore_pos')
    let g:screen_size_restore_pos = 1
  endif
  if !exists('g:screen_size_by_vim_instance')
    let g:screen_size_by_vim_instance = 1
  endif
  autocmd VimEnter * if g:screen_size_restore_pos == 1 | call ScreenRestore() | endif
  autocmd VimLeavePre * if g:screen_size_restore_pos == 1 | call ScreenSave() | endif
endif

